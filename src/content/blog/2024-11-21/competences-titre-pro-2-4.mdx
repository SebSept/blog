---
title: "üìë Dossier De Projet - 2/4 - Concevoir et d√©velopper la persistance des donn√©es"
pubDatetime: 2024-11-21
draft: false
tags: ["symfony", "doctrine", "sql"]
slug: "competences-titre-pro-2-4"
description: "Mon dossier de projet professionnel - 2/4 Concevoir et d√©velopper la persistance des donn√©es"
featured: false
---

import Callout from '/src/components/Callout/Callout.astro'

Ce post est le second d'une s√©rie de quatre articles qui d√©crivent mon dossier de projet professionnel. Le premier post se trouve [ici](/posts/dossier-de-projet).

# Concevoir et d√©velopper la persistance des donn√©es

Le bloc de comp√©tences s'intitule _Concevoir et d√©velopper la persistance des donn√©es en int√©grant les recommandations de s√©curit√©_. Il est compos√© de trois parties : [Concevoir une base de donn√©es](#concevoir-une-base-de-donn√©es), [Mettre en place une base de donn√©es](#mettre-en-place-une-base-de-donn√©es) et [D√©velopper des composants dans le langage d'une base de donn√©es](#mettre-en-place-une-base-de-donn√©es).

Ce sont des comp√©tences assez basiques, pour moi qui manipule les SGBD _MySQL_ et _MariaDB_ depuis des ann√©es. Pour le projet, j'ai choisi d'utiliser _PostgreSQL_, c'est le SGBD utilis√© par d√©faut par Symfony. Comme indiqu√© dans ma note de pr√©-d√©marrage, je m'efforce de me conformer aux standards et aux configurations initiales de _Symfony_. Je n'avais jamais eu l'occasion de l'utiliser. C'√©tait donc le bon moment, je disposais d'une marge de temps et que j'ai √©valu√© (dans la gestion du risque) que c'√©tait possible car le choix du SGBD ne figure pas dans les risques, tant il est mineur.

## Concevoir une base de donn√©es

J'ai initialement con√ßu la base de donn√©es  dans phpstorm avec le plugin [plantuml](https://plantuml.com/fr/) mais le r√©sultat n'√©tait pas tr√®s satisfaisant. UML n'est pas fait repr√©senter les bases de donn√©es. J'ai finalement utilis√© [LucidChart](https://www.lucidchart.com/), comme recommand√© dans les cours. Avec du recul et pour une prochaine fois, j'utiliserai peut-√™tre [dbdiagram.io](https://dbdiagram.io/home) qui semble parfaitement adapt√© √† la t√¢che.

Sur le fond, rien de tr√®s sorcier, c'est sans difficult√© que j'ai con√ßu une base de donn√©es normalis√©e, avec les cl√©s √©trang√®res, des index pertinents. Le rendu ici n'est pas fameux, mais √ßa n'est pas tr√®s important, car ce sch√©ma n'est pas un document de travail tr√®s utilis√©, comme on va le voir.

![Sch√©ma de la base de donn√©es](./base_de_donnees.png)

Une chose n'apparait pas dans ce sch√©ma, le fait qu'un _user_ peut √©galement avoir un r√¥le  secr√©taire ou administrateur. Ces utilisateurs n'ont pas de profil. On aurait pu le voir si on avait un type Enum pour les r√¥les dans le _user_, mais la norme dans le d√©veloppement Symfony semble √™tre de g√©rer les contraintes au niveau de l'entit√© Doctrine plus que dans la base de donn√©es.

<Callout title="Digression" icon="info">
  Par le pass√© j'ai d√©velopp√© une petite application pour g√©rer un championnat de poker entre amis. Tous les pr√©textes sont bons pour faire un petit projet de d√©veloppement. J'avais pris l'option d'utiliser les fonctions avanc√©es de la base de donn√©es, des vues, des proc√©dures et des triggers. Cot√© connaissances, c'√©tait tr√®s int√©ressant, cot√© architecture, organisation, c'est √† proscrire. La logique applicative est dispers√©e entre le code php et la base de donn√©es. Cela pr√©sente au moins deux probl√®mes qui font que j'√©vite d√©sormais ce type de pratiques.

1. La maintenance et les √©volutions deviennent p√©rilleuses, les migrations sur la base de donn√©es, sont couteuses, difficiles √† tester, difficiles √† corriger en production (√ßa peut arriver).
2. La compr√©hension du code est difficile, elle demande des comp√©tences avanc√©es en MySQL, et jongler en permanence entre code PHP et code SQL rend le travail p√©nible.

Bref, garder une base de donn√©es simple, sans trop de fonctionnalit√©s est un choix judicieux, en phase avec les pratiques et outils modernes. Faire autrement doit √™tre pr√©c√©d√© d'une contrainte tr√®s forte.
</Callout>

## Mod√©lisation avec Doctrine

Une fois le sch√©ma conceptuel r√©alis√©, la mod√©lisation se concr√©tise par l'impl√©mentation des entit√©s Doctrine.

Voici un exemple d'entit√© repr√©sentant un s√©jour √† l'h√¥pital :

```php
#[ORM\Entity(repositoryClass:HospitalStayRepository::class)]
classHospitalStay
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id =null;

    #[ORM\Column(type:Types::DATETIME_MUTABLE,nullable:true)]
    private ?DateTimeInterface $checkin =null;

    #[ORM\ManyToOne(inversedBy: 'hospitalStays')]
    #[ORM\JoinColumn(nullable: false)]
    #[Groups(['hospital_stay:read', 'hospital_stay:details'])]
    private ?Patient $patient = null;

    // ...
}
```

Cette approche de mod√©lisation via le code apporte au moins 2 avantages :

- Le code et la structure de la base de donn√©es sont d√©finis ensemble, c'est pratique et l'ide peut analyser tout √ßa.
- Les outils de l'IDE aident √† la saisie et √† la validation du code.

Il restait le probl√®me des migrations,  mais j'ai int√©gr√© les commandes de migrations au processus de d√©ploiement continue, ce qui r√®gle le probl√®me.

```yaml
  # d√©ploiement
  deploy:
    steps:
        with:
          script: |
           // ...
            docker compose exec php ./bin/console doctrine:migrations:migrate --no-interaction --allow-no-migration
```
Le code en question est dans le [workflow de d√©ploiement GitHub](https://github.com/SebSept/soignemoi-api/blob/dea5859c23cc8e80037de1ccaeb8d047abf15f3a/.github/workflows/deploy.yaml#L53).

## Mettre en place une base de donn√©es

La mise en place concr√®te de la base de donn√©es est r√©alis√©e par Doctrine en tenant compte des entit√©s d√©finies dans le code PHP.

La cr√©ation des tables est faite avec la commande :

```bash
php bin/console doctrine:schema:create
```

Les modifications de sch√©ma passent par un syst√®me de migrations. Une migration est un fichier PHP qui d√©crit les modifications √† apporter au sch√©ma existant pour le faire √©voluer.

Pour g√©n√©rer une migration, il suffit d'ex√©cuter la commande :

```bash
php bin/console make:migration
```

Doctrine compare alors le sch√©ma actuel de la base avec le sch√©ma d√©crit par les entit√©s. Il g√©n√®re le code n√©cessaire pour passer de l'un √† l'autre.

Pour jouer les migrations et mettre √† jour concr√®tement la base, on lance :

```bash
php bin/console doctrine:migrations:migrate
```

Ce processus rend l'√©volution du sch√©ma simple et s√ªre. On peut facilement revenir en arri√®re en annulant une migration si besoin.

## D√©velopper des composants dans le langage d'une base de donn√©es

Avec Doctrine, les interactions avec la base se font dans des classes particuli√®res appel√©es "repositories". Pour chaque entit√©, on peut d√©finir une classe repository qui contiendra les m√©thodes permettant d'effectuer des requ√™tes sp√©cifiques.

Voici un exemple de m√©thode dans un repository permettant de r√©cup√©rer les s√©jours d'un m√©decin pour la journ√©e courante :

```php
classHospitalStayRepository extendsServiceEntityRepository
{
    /**
     * @return array<HospitalStay>
     */
    public functionfindByDoctorForToday(int $doctor_id): array
    {
        return$this->createQueryBuilder('h')
            ->where('h.doctor = :doctor_id')
            ->andWhere('h.checkin IS NOT NULL')
            ->andWhere('h.checkout IS NULL')
            ->setParameter('doctor_id',$doctor_id)
            ->getQuery()
            ->getResult();
    }
}
```

On utilise le Query Builder de Doctrine pour construire une requ√™te avec plusieurs clauses WHERE. La m√©thode `setParameter` permet de passer des param√®tres √† la requ√™te de mani√®re s√©curis√©e, en √©vitant les injections SQL.

Quelques points √† noter :

- Les requ√™tes sont construites sous forme d'objets, avec une approche fluide (cha√Ænage de m√©thodes).
- On ne manipule pas directement du SQL, mais un langage de requ√™te orient√© objet (DQL).
- Les r√©sultats sont directement retourn√©s sous forme d'objets PHP (ici un tableau d'objets `HospitalStay`).

Cette approche apporte une abstraction par rapport au SQL pur, tout en permettant d'√©crire des requ√™tes complexes si n√©cessaire. Les avantages sont multiples :

- Le code est plus lisible et maintenable, proche du langage objet.
- On limite les erreurs li√©es √† la construction manuelle de requ√™tes SQL.
- Le code est portable, ind√©pendant du SGBD utilis√©.
- Les performances sont optimis√©es, Doctrine g√©n√®re des requ√™tes efficaces.

## Conclusion

Par contre, dans le contexte d'un dossier de projet, √ßa n'aide pas vraiment √† valider les comp√©tence... @todo

Le travail sur la persistance des donn√©es lors de ce projet m'a permis d'approfondir plusieurs aspects :

- La conception d'un sch√©ma de base de donn√©es coh√©rent et normalis√©.
- La mise en place d'une base de donn√©es avec un processus d'√©volution ma√Ætris√©.
- L'utilisation d'un ORM mature pour faciliter les interactions avec la base.
- La prise en compte des aspects de s√©curit√© (injection SQL, param√®tres de requ√™tes).

Au-del√† des comp√©tences techniques, cette exp√©rience a renforc√© mon approche m√©thodologique et ma capacit√© √† int√©grer de nouveaux outils et pratiques de mani√®re r√©fl√©chie et pragmatique. Choisir les bons outils, savoir quand utiliser ou non une fonctionnalit√©, comprendre les principes sous-jacents... Autant de r√©flexes qui font la diff√©rence dans la qualit√© et la maintenabilit√© des d√©veloppements.

En r√©sum√©, ce projet a √©t√© l'occasion de monter en comp√©tence sur la persistance des donn√©es de mani√®re tr√®s concr√®te, en allant bien au-del√† de la simple utilisation d'un SGBD. Une exp√©rience enrichissante qui servira de base solide pour les projets √† venir.

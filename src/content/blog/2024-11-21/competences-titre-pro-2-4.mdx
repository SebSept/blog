---
title: "üìë Dossier De Projet - 2/4 - Concevoir et d√©velopper la persistance des donn√©es"
pubDatetime: 2024-11-21
draft: false
tags: ["symfony", "doctrine", "sql", "projet"]
slug: "competences-titre-pro-2-4"
description: "Mon dossier de projet professionnel - 2/4 Concevoir et d√©velopper la persistance des donn√©es"
featured: false
---

import Callout from '/src/components/Callout/Callout.astro'

<Callout>
Dans cet article je pr√©sente rapidement les comp√©tences li√©es aux bases de donn√©es, mises en oeuvre dans mon projet de certification.
Cet article est le second d'une s√©rie de quatre articles qui d√©crivent mon dossier de projet professionnel.
</Callout>

Le premier post se trouve [ici](/posts/dossier-de-projet).

# Concevoir et d√©velopper la persistance des donn√©es

Le bloc de comp√©tences s'intitule _Concevoir et d√©velopper la persistance des donn√©es en int√©grant les recommandations de s√©curit√©_. Il est compos√© de trois parties : [Concevoir une base de donn√©es](#concevoir-une-base-de-donn√©es), [Mettre en place une base de donn√©es](#mettre-en-place-une-base-de-donn√©es) et [D√©velopper des composants dans le langage d'une base de donn√©es](#mettre-en-place-une-base-de-donn√©es).

Ce sont des comp√©tences assez basiques, pour moi qui manipule les SGBD _MySQL_ et _MariaDB_ depuis des ann√©es. Pour le projet, j'ai choisi d'utiliser _PostgreSQL_, c'est le SGBD utilis√© par d√©faut par Symfony. Comme indiqu√© dans ma note de pr√©-d√©marrage, je m'efforce de me conformer aux standards et aux configurations initiales de _Symfony_. Je n'avais jamais eu l'occasion de l'utiliser. C'√©tait donc le bon moment, je disposais d'une marge de temps et c'est peu risqu√© (rejet√© des risques, tant l'impact est faible).

## Concevoir une base de donn√©es

J'ai initialement con√ßu la base de donn√©es  dans phpstorm avec le plugin [plantuml](https://plantuml.com/fr/) mais le r√©sultat n'√©tait pas tr√®s satisfaisant. UML n'est pas fait pour repr√©senter les bases de donn√©es. J'ai finalement utilis√© [LucidChart](https://www.lucidchart.com/), comme recommand√© dans les cours. Avec du recul et pour une prochaine fois, j'utiliserai peut-√™tre [dbdiagram.io](https://dbdiagram.io/home) qui semble parfaitement adapt√© √† la t√¢che.

Sur le fond, rien de tr√®s sorcier, c'est sans difficult√© que j'ai con√ßu une base de donn√©es normalis√©e, avec les cl√©s √©trang√®res, des index pertinents. Le rendu ici n'est pas fameux, mais √ßa n'est pas tr√®s important, car ce sch√©ma n'est pas un document de travail tr√®s utilis√©, comme on va le voir.

![Sch√©ma de la base de donn√©es](./base_de_donnees.png)

Une chose n'apparait pas dans ce sch√©ma, le fait qu'un _user_ peut √©galement avoir un r√¥le  secr√©taire ou administrateur. Ces utilisateurs n'ont pas de profil. On aurait pu le voir si on avait un type Enum pour les r√¥les dans le _user_, mais la norme dans le d√©veloppement Symfony semble √™tre de g√©rer les contraintes au niveau de l'entit√© Doctrine plus que dans la base de donn√©es.

<Callout title="Digression" icon="info">
  Par le pass√©, j'ai d√©velopp√© une petite application pour g√©rer un championnat de poker entre amis (tous les pr√©textes sont bons pour faire un petit projet de d√©veloppement). J'avais pris l'option d'utiliser les fonctions avanc√©es de la base de donn√©es, des vues, des proc√©dures et des triggers. Cot√© connaissances, c'√©tait tr√®s int√©ressant, cot√© architecture, organisation, c'est √† proscrire car **la logique applicative est dispers√©e entre le code php et la base de donn√©es**.

1. La maintenance et les √©volutions deviennent p√©rilleuses, les migrations sur la base de donn√©es, sont couteuses, difficiles √† tester, difficiles √† corriger en production (√ßa peut arriver).
2. La compr√©hension du code est difficile, elle demande des comp√©tences avanc√©es en MySQL, et jongler en permanence entre code PHP et code SQL rend le travail p√©nible.

Bref, garder une base de donn√©es simple est un choix judicieux, en phase avec les pratiques et outils modernes. Faire autrement doit √™tre pr√©c√©d√© d'une contrainte tr√®s forte.
</Callout>

## Mod√©lisation avec Doctrine

Une fois le Mod√®le Conceptuel de Donn√©es r√©alis√©, la mod√©lisation en classe √©crite, j'ai concr√©tis√© la conception par l'impl√©mentation des entit√©s Doctrine.

Voici un exemple d'entit√© repr√©sentant un s√©jour √† l'h√¥pital :

```php
#[ORM\Entity(repositoryClass:HospitalStayRepository::class)]
classHospitalStay
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id =null;

    #[ORM\Column(type:Types::DATETIME_MUTABLE,nullable:true)]
    private ?DateTimeInterface $checkin =null;

    #[ORM\ManyToOne(inversedBy: 'hospitalStays')]
    #[ORM\JoinColumn(nullable: false)]
    #[Groups(['hospital_stay:read', 'hospital_stay:details'])]
    private ?Patient $patient = null;

    // ...
}
```

Cette approche de mod√©lisation via le code apporte au moins 2 avantages :

- Le code et la structure de la base de donn√©es sont d√©finis ensemble
- L'IDE (phpstorm) aide √† la saisie et √† la validation du code, de la coh√©rence.

Il restait le probl√®me des migrations, qui restent dissoci√©es, mais j'ai int√©gr√© les commandes de migrations au processus de d√©ploiement continue, ce qui r√®gle le probl√®me.

```yaml
  # d√©ploiement
  deploy:
    steps:
        with:
          script: |
           // ...
            docker compose exec php ./bin/console doctrine:migrations:migrate --no-interaction --allow-no-migration
```
Le code en question est dans le [workflow de d√©ploiement GitHub](https://github.com/SebSept/soignemoi-api/blob/dea5859c23cc8e80037de1ccaeb8d047abf15f3a/.github/workflows/deploy.yaml#L53).

## Mettre en place une base de donn√©es

Il s'agit d'une part d'installer et configurer un SGBD, de fa√ßon s√©curis√©e. A nouveau avec Docker, c'est simple, j'ai pu me concentrer sur la s√©curit√©.

La mise en place est r√©alis√©e par Doctrine en tenant compte des entit√©s d√©finies dans le code PHP. La cr√©ation des tables est faite simplement avec la commande :

```bash
php bin/console doctrine:schema:create
```

Les migrations avec Doctrine sont simples car g√©n√©r√©es avec la commande

```bash
php bin/console make:migration
```

Doctrine compare alors le sch√©ma actuel de la base avec le sch√©ma d√©crit par les entit√©s. Il g√©n√®re le code n√©cessaire pour passer de l'un √† l'autre.

Pour jouer les migrations et mettre √† jour concr√®tement la base, on lance :

```bash
php bin/console doctrine:migrations:migrate
```

Ce processus rend l'√©volution du sch√©ma simple et s√ªre. On peut facilement revenir en arri√®re en annulant une migration si besoin.

Cette fa√ßon de faire nous √©loigne des consid√©rations purement d'√©criture de code SQL, pour la validation de mes comp√©tences, j'ai fait valoir mon exp√©rience de d√©veloppeur PrestaShop. J'ai √©crit des migrations SQL _brute_ (ou presque) (cr√©ation de tables, modification de champs, etc). J'ai √©crit des scripts de migration de version de PHP, des scripts d'insertion de donn√©es dans le catalogue, _dump√©_ des bases ou des tables, mis en place des sauvegardes, proc√©d√© √† des r√©cup√©rations/injections partielles de donn√©es, beaucoup de t√¢ches dans ce domaine. C'est pourquoi, j'ai pu utiliser Doctrine sans me pr√©occuper du travail directement au niveau SQL dans ce projet.

## D√©velopper des composants dans le langage d'une base de donn√©es

√Ä nouveau, pas d'√©criture de SQL directement, les instructions les plus proches du langage sont des requ√™tes r√©alis√©es avec le QueryBuilder.
Voici un exemple de m√©thode dans un repository permettant de r√©cup√©rer les s√©jours d'un m√©decin pour la journ√©e courante :

```php
classHospitalStayRepository extendsServiceEntityRepository
{
    /**
     * @return array<HospitalStay>
     */
    public function findByDoctorForToday(int $doctor_id): array
    {
        return$this->createQueryBuilder('h')
            ->where('h.doctor = :doctor_id')
            ->andWhere('h.checkin IS NOT NULL')
            ->andWhere('h.checkout IS NULL')
            ->setParameter('doctor_id',$doctor_id)
            ->getQuery()
            ->getResult();
    }
}
```
C'est assez facile √† √©crire, on √©vite les erreurs de syntaxe _idiotes_ et le point int√©ressant, c'est qu'en utilisant la m√©thode `setParameter` pour d√©finir les parties variables de la requ√™te, on √©crit du code s√©curis√© sans effort, on se prot√®ge des injections SQLs.
Les r√©sultats sont directement retourn√©s sous forme d'objets PHP (ici un tableau d'objets `HospitalStay`). Cette approche apporte une abstraction par rapport au SQL pur, tout en permettant d'√©crire des requ√™tes complexes si n√©cessaire. Les avantages sont multiples :

- Le code est plus lisible et maintenable, proche du langage objet.
- On limite les erreurs li√©es √† la construction manuelle de requ√™tes SQL.
- Le code est portable, ind√©pendant du SGBD utilis√©.
- Les performances sont optimis√©es, Doctrine g√©n√®re des requ√™tes efficaces.

Savoir √©crire du SQL c'est tr√®s bien, on est for√ß√©ment amen√© le faire par moment, √ßa n'emp√™che pas d'utiliser des abstractions quand on peut.

## Conclusion

Le travail sur la persistance des donn√©es lors de ce projet m'a permis d'approfondir plusieurs aspects :

- La conception d'un sch√©ma de base de donn√©es coh√©rent et normalis√©
- La mise en place d'une base de donn√©es avec un processus d'√©volution ma√Ætris√©
- L'utilisation d'un ORM mature pour faciliter les interactions avec la base
- La prise en compte des aspects de s√©curit√© (injection SQL, param√®tres de requ√™tes)

Au-del√† des comp√©tences techniques, cette exp√©rience a renforc√© mon approche m√©thodologique et ma capacit√© √† int√©grer de nouveaux outils et pratiques de mani√®re r√©fl√©chie et pragmatique. Choisir les bons outils, savoir quand utiliser ou non une fonctionnalit√©, comprendre les principes sous-jacents sont autant de r√©flexes qui font la diff√©rence dans la qualit√© et la maintenabilit√© des d√©veloppements.

En r√©sum√©, ce projet a √©t√© l'occasion de monter en comp√©tences sur la persistance des donn√©es de mani√®re tr√®s concr√®te, en allant bien au-del√† de la simple utilisation d'un SGBD. Cette exp√©rience enrichissante servira de base solide pour les projets √† venir.
---
title: "üìë Dossier De Projet - 4/4 - Concevoir et d√©velopper une application multicouche - Tests et d√©ploiement"
pubDatetime: 2024-12-09
draft: false
tags: ["tests", "docker", "titrepro"]
slug: "competences-titre-pro-4-4"
description: "Mon dossier de projet professionnel - 4/4 Construction, tests et d√©ploiement"
featured: false
---

import Callout from '/src/components/Callout/Callout.astro'

<Callout>Ce dernier article de la s√©rie explore les aspects techniques de la construction, du test et du d√©ploiement de l'application. J'explique rapidement ici comment j'ai mis en ≈ìuvre une approche DevOps compl√®te, de l'√©criture du code jusqu'√† la mise en production.</Callout>

Pour le stack technique, vous pouvez vous r√©f√©rer √† [l'article pr√©c√©dent de cette s√©rie](/posts/competences-titre-pro-3-4).

## Construction de l'application en couches

L'application cliente est structur√©e selon le pattern MVC (Mod√®le-Vue-Contr√¥leur) propos√© par Symfony. Cette architecture en couches permet une s√©paration claire des responsabilit√©s :

- La couche pr√©sentation est g√©r√©e par le moteur de templates Twig
- La couche m√©tier comprend le service d'API et les objets DTO
- La couche persistance se limite aux requ√™tes vers l'API

Cette s√©paration se refl√®te dans l'organisation du code. Par exemple, pour la gestion des s√©jours hospitaliers :

```php
class HospitalStayController extends AbstractController
{
    #[Route('/secretary/checkout/{hospitalStayId}', name: 'app_hospital_stay_checkout')]
    public function checkoutEntry(int $hospitalStayId): RedirectResponse
    {
        $this->apiService->checkoutEntry($hospitalStayId);
        $this->addFlash('success', 'Sortie enregistr√©e.');
        return $this->redirectToRoute('app_secretary_home');
    }
}
```

Le contr√¥leur reste minimal et d√©l√®gue le traitement au service d'API, illustrant parfaitement la s√©paration des responsabilit√©s.

## D√©veloppement de l'application mobile

Pour l'application mobile, j'ai choisi une approche pragmatique avec Flutter. L'application se pr√©sente comme une webview affichant le client web :

```dart
class WebViewApp extends StatefulWidget {
  const WebViewApp({super.key});

  @override
  State<WebViewApp> createState() => _WebViewAppState();
}

class _WebViewAppState extends State<WebViewApp> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: WebViewWidget(
        controller: _MyWebViewController(),
      ),
    );
  }
}
```

Cette approche minimaliste mais efficace permet de :
- R√©utiliser l'interface web d√©j√† d√©velopp√©e
- B√©n√©ficier de l'approche mobile-first du client web
- Minimiser la maintenance en centralisant les √©volutions

## Strat√©gie de tests

J'ai structur√© les tests en trois phases distinctes :

1. Tests de d√©veloppement : approche TDD, tests unitaires syst√©matiques
2. Tests de conformit√© : v√©rification des exigences fonctionnelles
3. Tests de s√©curit√© : utilisation d'outils sp√©cialis√©s comme sqlmap

Voici un exemple de test v√©rifiant les autorisations :

```php
public function testADoctorCannotCreateAnHospitalStay(): void
{
    // Arrange
    $doctorUser = UserFactory::new()->doctor()->create();
    $doctor = $doctorUser->getDoctor();

    // Act
    $this->browser()->actingAs($doctorUser->object())
        ->post(
            '/api/hospital_stays',
            HttpOptions::json([
                'startDate' => '2024-01-01',
                'reason' => 'Mal de t√™te',
                // ...
            ]));

    // Assert
    ->assertStatus(403);
}
```

Ces tests, int√©gr√©s dans la cha√Æne d'int√©gration continue, assurent la stabilit√© du code.

## D√©ploiement automatis√©

Le d√©ploiement repose sur une cha√Æne d'int√©gration continue GitHub Actions :

```yaml
name: Deployment
on:
  push:
    branches:
      - main
jobs:
  integration:
    uses: ./.github/workflows/integration.yaml
    secrets: inherit
  deploy:
    needs: integration
    runs-on: ubuntu-latest
    steps:
      - name: Deployment
        uses: appleboy/ssh-action@f9163462563f649b27272d32e585525a5fe68d76
        with:
          host: api.ecf.seb7.fr
          username: root
          key: ${{ secrets.SERVER_SSH_KEY }}
```

L'infrastructure est g√©r√©e via Docker Compose, permettant une mise √† jour atomique de l'ensemble des services :

```yaml
services:
  php:
    image: ghcr.io/sebsept/docker-php-symfony-starter:prod
    volumes:
      - ./:/app
    networks:
      - nginx
      - postgres
  nginx:
    image: nginx:1.26.0
    volumes:
      - ./docker/nginx_prod.conf:/etc/nginx/conf.d/default.conf
      - ./public:/app/public
```

Cette configuration assure :
- Une mise √† jour automatis√©e du code et des conteneurs
- Une persistance des donn√©es via des volumes Docker
- Une isolation des services par des r√©seaux d√©di√©s pour une s√©curit√© optimale

## Conclusion

La mise en place d'une architecture en couches, coupl√©e √† une strat√©gie de tests rigoureuse et un d√©ploiement automatis√©, a permis de livrer une solution robuste et maintenable. Cette approche DevOps compl√®te garantit la qualit√© du code et simplifie les √©volutions futures.

L'ensemble des articles de cette s√©rie d√©montre comment une approche m√©thodique, de la conception au d√©ploiement, permet de r√©aliser un projet complexe tout en maintenant un haut niveau de qualit√©.

Si vous souhaitez entrer dans les d√©tails, mon dossier de projet est [disponible en t√©l√©chargement](http://dev.seb7.fr/dossier_de_projet.pdf).